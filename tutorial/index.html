



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Directional-Field Processing Library">
      
      
        <link rel="canonical" href="https://avaxman.github.io/Directional/tutorial/">
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.1, mkdocs-material-3.0.3">
    
    
      
        <title>Tutorial - Directional</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="#03a9f4">
      
    
    
      <script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
      
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
      <link rel="stylesheet" href="../css/style.css">
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="../#introduction" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://avaxman.github.io/Directional/" title="Directional" class="md-header-nav__button md-logo">
          
            <i class="md-icon"> </i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                Directional
              </span>
              <span class="md-header-nav__topic">
                Tutorial
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/avaxman/Directional.git/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      Directional
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://avaxman.github.io/Directional/" title="Directional" class="md-nav__button md-logo">
      
        <i class="md-icon"> </i>
      
    </a>
    Directional
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/avaxman/Directional.git/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      Directional
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Tutorial
      </label>
    
    <a href="./" title="Tutorial" class="md-nav__link md-nav__link--active">
      Tutorial
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" title="Introduction" class="md-nav__link">
    Introduction
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#installing-the-tutorial-examples" title="Installing the tutorial examples" class="md-nav__link">
    Installing the tutorial examples
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#discretization" title="Discretization" class="md-nav__link">
    Discretization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#representation" title="Representation" class="md-nav__link">
    Representation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-1-io-and-visualization" title="Chapter 1: I/O and Visualization" class="md-nav__link">
    Chapter 1: I/O and Visualization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#visualization-paradigm" title="Visualization paradigm" class="md-nav__link">
    Visualization paradigm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#101-glyph-rendering" title="101 Glyph Rendering" class="md-nav__link">
    101 Glyph Rendering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-picking-and-editing" title="102 Picking and editing" class="md-nav__link">
    102 Picking and editing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-streamline-tracing" title="103 Streamline Tracing" class="md-nav__link">
    103 Streamline Tracing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-discretization-and-representation" title="Chapter 2: Discretization and Representation" class="md-nav__link">
    Chapter 2: Discretization and Representation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#201-principal-matching" title="201 Principal Matching" class="md-nav__link">
    201 Principal Matching
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#202-sampling" title="202 Sampling" class="md-nav__link">
    202 Sampling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#203-combing" title="203 Combing" class="md-nav__link">
    203 Combing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-cartesian-methods" title="Chapter 3: Cartesian Methods" class="md-nav__link">
    Chapter 3: Cartesian Methods
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cartesian-fields" title="Cartesian Fields" class="md-nav__link">
    Cartesian Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#301-power-fields" title="301 Power Fields" class="md-nav__link">
    301 Power Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#302-polyvectors" title="302 PolyVectors" class="md-nav__link">
    302 PolyVectors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#303-polycurl-reduction" title="303 PolyCurl Reduction" class="md-nav__link">
    303 PolyCurl Reduction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#304-conjugate-fields" title="304 Conjugate Fields" class="md-nav__link">
    304 Conjugate Fields
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-polar-methods" title="Chapter 4: Polar Methods" class="md-nav__link">
    Chapter 4: Polar Methods
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polar-fields" title="Polar Fields" class="md-nav__link">
    Polar Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#401-index-prescription" title="401 Index Prescription" class="md-nav__link">
    401 Index Prescription
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basis-cycles" title="Basis Cycles" class="md-nav__link">
    Basis Cycles
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-seamless-parameterization" title="Chapter 5: Seamless Parameterization" class="md-nav__link">
    Chapter 5: Seamless Parameterization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#501-seamless-parameterization" title="501 Seamless Parameterization" class="md-nav__link">
    501 Seamless Parameterization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#502-mixed-integer-parametrization" title="502 Mixed-Integer Parametrization" class="md-nav__link">
    502 Mixed-Integer Parametrization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outlook-for-continuing-development" title="Outlook for continuing development" class="md-nav__link">
    Outlook for continuing development
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" title="References" class="md-nav__link">
    References
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../file_formats/" title="File Formats" class="md-nav__link">
      File Formats
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../website/" title="Website" class="md-nav__link">
      Website
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../faq.md" title="FAQ" class="md-nav__link">
      FAQ
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../RELEASE_HISTORY/" title="Release History" class="md-nav__link">
      Release History
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" title="Introduction" class="md-nav__link">
    Introduction
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#installing-the-tutorial-examples" title="Installing the tutorial examples" class="md-nav__link">
    Installing the tutorial examples
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#discretization" title="Discretization" class="md-nav__link">
    Discretization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#representation" title="Representation" class="md-nav__link">
    Representation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-1-io-and-visualization" title="Chapter 1: I/O and Visualization" class="md-nav__link">
    Chapter 1: I/O and Visualization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#visualization-paradigm" title="Visualization paradigm" class="md-nav__link">
    Visualization paradigm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#101-glyph-rendering" title="101 Glyph Rendering" class="md-nav__link">
    101 Glyph Rendering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#102-picking-and-editing" title="102 Picking and editing" class="md-nav__link">
    102 Picking and editing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#103-streamline-tracing" title="103 Streamline Tracing" class="md-nav__link">
    103 Streamline Tracing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-discretization-and-representation" title="Chapter 2: Discretization and Representation" class="md-nav__link">
    Chapter 2: Discretization and Representation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#201-principal-matching" title="201 Principal Matching" class="md-nav__link">
    201 Principal Matching
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#202-sampling" title="202 Sampling" class="md-nav__link">
    202 Sampling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#203-combing" title="203 Combing" class="md-nav__link">
    203 Combing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-cartesian-methods" title="Chapter 3: Cartesian Methods" class="md-nav__link">
    Chapter 3: Cartesian Methods
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cartesian-fields" title="Cartesian Fields" class="md-nav__link">
    Cartesian Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#301-power-fields" title="301 Power Fields" class="md-nav__link">
    301 Power Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#302-polyvectors" title="302 PolyVectors" class="md-nav__link">
    302 PolyVectors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#303-polycurl-reduction" title="303 PolyCurl Reduction" class="md-nav__link">
    303 PolyCurl Reduction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#304-conjugate-fields" title="304 Conjugate Fields" class="md-nav__link">
    304 Conjugate Fields
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-polar-methods" title="Chapter 4: Polar Methods" class="md-nav__link">
    Chapter 4: Polar Methods
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#polar-fields" title="Polar Fields" class="md-nav__link">
    Polar Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#401-index-prescription" title="401 Index Prescription" class="md-nav__link">
    401 Index Prescription
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basis-cycles" title="Basis Cycles" class="md-nav__link">
    Basis Cycles
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-seamless-parameterization" title="Chapter 5: Seamless Parameterization" class="md-nav__link">
    Chapter 5: Seamless Parameterization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#501-seamless-parameterization" title="501 Seamless Parameterization" class="md-nav__link">
    501 Seamless Parameterization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#502-mixed-integer-parametrization" title="502 Mixed-Integer Parametrization" class="md-nav__link">
    502 Mixed-Integer Parametrization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outlook-for-continuing-development" title="Outlook for continuing development" class="md-nav__link">
    Outlook for continuing development
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" title="References" class="md-nav__link">
    References
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/avaxman/avaxman.github.io/edit/docs/docs/tutorial.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1>Directional tutorial notes</h1>

<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Directional is a C++ geometry processing library written as an extension library to <a href="http://libigl.github.io/libigl/">libigl</a>, with a specialization in directional-field processing. The functionality is based on the definitions and taxonomy surveyed theoretically in <sup id="fnref:vaxman_2016"><a class="footnote-ref" href="#fn:vaxman_2016" rel="footnote">16</a></sup>, and through it by the relevant papers in the literature. It contains tools to edit, analyze, and visualize directional fields of various degrees and symmetries.</p>
<p>The underlying structure extends the general philosophy of <a href="http://libigl.github.io/libigl/">libigl</a>: the library is header only, where each header contains a set of functions closely related (for instance, the precomputation and computation of some directional quantity over a mesh). For the most part, one header contains only one function. The data structures are, for the most part, simple matrices in <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, and the library avoids complicated and nested structures, relying instead on standalone functions. The visualization is done on the basis of <a href="http://libigl.github.io/libigl/">libigl</a> viewer, with some extended options that allow the rendering of directional fields.</p>
<p>The header files contain documentation of the parameters to each function and their required composition; in this tutorial we will mostly tie the functionality of Directional to the theoretical concepts of directional fields and the methods to process them.</p>
<h3 id="installing-the-tutorial-examples">Installing the tutorial examples<a class="headerlink" href="#installing-the-tutorial-examples" title="Permanent link">&para;</a></h3>
<p>This tutorial comprises an exhaustive set of examples that demonstrates the capabilities of Directional, where every subchapter entails a single concept. The tutorial code can be installed by going into the <code class="codehilite">tutorial</code> folder from the main Directional folder, and typing the following instructions in a terminal:</p>
<div class="codehilite"><pre><span></span><span class="n">mkdir</span> <span class="n">build</span>
<span class="n">cd</span> <span class="n">build</span>
<span class="n">cmake</span> <span class="o">-</span><span class="n">DCMAKE_BUILD_TYPE</span><span class="o">=</span><span class="n">Release</span> <span class="p">..</span><span class="o">/</span>
<span class="n">make</span>
</pre></div>

<p>This will build all tutorial chapters in the <code class="codehilite">build</code> folder. The necessary dependencies will be appended and built automatically. To build in windows, use the <code class="codehilite">cmake-gui ..</code> options instead of the last two commands, and create the project using Visual Studio, with the proper tutorial subchapter as the &ldquo;startup project&rdquo;.</p>
<p>To access a single example, say <code class="codehilite">202_Sampling</code>, go to the <code class="codehilite">build</code> subfolder, and the executable will be there. Command-line arguments are never required; the data is read from the <code class="codehilite">shared</code> folder directly for each example.</p>
<p>Most examples require a modest amount of user interaction; the instructions of what to do are given in the command-line output upon execution.</p>
<h3 id="discretization">Discretization<a class="headerlink" href="#discretization" title="Permanent link">&para;</a></h3>
<p>There are several ways to represent tangent planes on triangle meshes, although not all of them compatible with the different information that the fields convey. Mainstream discretizations roughly categorize into face-based, edge-based, and vertex-basex discretizations (see <sup id="fnref:degoes_2016"><a class="footnote-ref" href="#fn:degoes_2016" rel="footnote">8</a></sup> for an in-depth analysis). The only discretization currently supported by Directional is that of tangent face-based fields, where the discrete tangent plane is taken to be the supporting plane to each (naturally flat) face. We also use a local basis (provided by <code class="codehilite">igl::local_basis()</code>) to parameterize each tangent plane. Notions like connection, parallel transport, and consequently smoothness, are measured on <em>dual edges</em> between adjacent faces.</p>
<h3 id="representation">Representation<a class="headerlink" href="#representation" title="Permanent link">&para;</a></h3>
<p>The representation of a directional field is the way it is encoded in each discrete tangent plane, and across adjacent tangent planes. Directional uses several different representations to describe directional fields. We denote the number of faces in the mesh as <span><span class="MathJax_Preview">|F|</span><script type="math/tex">|F|</script></span>, the set of inner edges (adjacent to two triangles) as <span><span class="MathJax_Preview">E_I</span><script type="math/tex">E_I</script></span>, and the degree of the field as <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> (must be fixed for the entire field). The supported  representations are as follows, where the taxonomy is based on that of the directional field course <sup id="fnref2:vaxman_2016"><a class="footnote-ref" href="#fn:vaxman_2016" rel="footnote">16</a></sup>:</p>
<ol>
<li><strong>Raw</strong> - A <span><span class="MathJax_Preview">|F|\times 3N</span><script type="math/tex">|F|\times 3N</script></span> double matrix, representing an <span><span class="MathJax_Preview">1^N</span><script type="math/tex">1^N</script></span>-vector field (a directional with <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> independent vectors in each face) in the form <span><span class="MathJax_Preview">X_1, Y_1, Z_1, X_2, Y_2, Z_2, \cdots X_N, Y_N, Z_N</span><script type="math/tex">X_1, Y_1, Z_1, X_2, Y_2, Z_2, \cdots X_N, Y_N, Z_N</script></span> per face. Vectors are assumed to be ordered in counterclockwise order in most Directional functions that process raw fields.</li>
<li><strong>Representative</strong>. A <span><span class="MathJax_Preview">|F| \times 3</span><script type="math/tex">|F| \times 3</script></span> double matrix that represents a rotationally symmetric <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-vector field, known as an <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy. The single vector is an arbitrary &ldquo;first&rdquo; vector in the face, and the rest of the vectors are deduced by rotations of <span><span class="MathJax_Preview">\frac{2\cdot\pi}{N}</span><script type="math/tex">\frac{2\cdot\pi}{N}</script></span>. That means the all functions should also accept <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> as input to decode the full field.</li>
<li><strong>Rotation Angles</strong>. A <span><span class="MathJax_Preview">|E_I|</span><script type="math/tex">|E_I|</script></span>-sized double vector representing the rotation angle between two directions (without magnitude information) on two adjacent triangles. The rotation represents the deviation from the Levi-Civita parallel transport <sup id="fnref4:crane_2010"><a class="footnote-ref" href="#fn:crane_2010" rel="footnote">5</a></sup>,<sup id="fnref3:ray_2008"><a class="footnote-ref" href="#fn:ray_2008" rel="footnote">11</a></sup>. This representation may only encode <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-direction fields (no magnitude). Note that the <em>effort</em> (sum of all rotations) is then <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> times rotation angles. Since this is a differential quantity, an extra global rotation needs to be given to uniquely decode the full face-based field.</li>
<li><strong>Power Field</strong> - An <span><span class="MathJax_Preview">|F|</span><script type="math/tex">|F|</script></span>-sized <em>complex</em> vector, encoding an <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy object as a single complex number <span><span class="MathJax_Preview">y=u^N</span><script type="math/tex">y=u^N</script></span> encoded in the local basis, where the <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy is the set of roots <span><span class="MathJax_Preview">u \cdot e^{\frac{2\pi i k}{N}}, k \in [0,N-1]</span><script type="math/tex">u \cdot e^{\frac{2\pi i k}{N}}, k \in [0,N-1]</script></span>. The magnitude is also encoded this way, though it may be neglected in some applications. The representation depends on a local <span><span class="MathJax_Preview">2D</span><script type="math/tex">2D</script></span> basis, such as one that could be obtained from <code class="codehilite">igl::local_basis()</code>.</li>
<li><strong>PolyVector</strong> - A <span><span class="MathJax_Preview">|F| \times N</span><script type="math/tex">|F| \times N</script></span> complex matrix, representing the coefficients <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> of a monic complex polynomial <span><span class="MathJax_Preview">f(z)=z^N+\sum_{i=0}^{N-1}{a_iz^i}</span><script type="math/tex">f(z)=z^N+\sum_{i=0}^{N-1}{a_iz^i}</script></span>, which roots <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> are the encoded <span><span class="MathJax_Preview">1^N</span><script type="math/tex">1^N</script></span>-vector field. Every row is encoded as <span><span class="MathJax_Preview">a_{0},\cdots, a_{N-1}</span><script type="math/tex">a_{0},\cdots, a_{N-1}</script></span>, where <span><span class="MathJax_Preview">a_0</span><script type="math/tex">a_0</script></span> is the free coefficient. In case where the field is an <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy, all coefficients but <span><span class="MathJax_Preview">a_0</span><script type="math/tex">a_0</script></span> are zero.</li>
</ol>
<p>Directional provides a number of conversion functions to switch between different representations. Each of the functions is of the form <code class="codehilite">rep1_to_rep2</code>, where <code class="codehilite">rep1</code> and <code class="codehilite">rep2</code> are the representation names in the above list. e.g., <code class="codehilite">rotation_to_representative()</code> and  <code class="codehilite">polyvector_to_raw()</code>. Some possible combinations are given by composing two functions in sequence. However, note that every conversion is possible; for instance, it is not possible to convert between PolyVectors and rotation angles, as they do not possess the same power of expression (with current state-of-the-art&hellip;). For <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy fields, for instance, you will most likely work primarily with the power field, representative, or rotation-angle representation. converting into the more explicit raw representation is often needed for I/O and visualization.</p>
<h2 id="chapter-1-io-and-visualization">Chapter 1: I/O and Visualization<a class="headerlink" href="#chapter-1-io-and-visualization" title="Permanent link">&para;</a></h2>
<h3 id="visualization-paradigm">Visualization paradigm<a class="headerlink" href="#visualization-paradigm" title="Permanent link">&para;</a></h3>
<p>Directional uses the libigl viewer (although a viewer is not necessary for the core functionality), and augments it with auxiliary functionality and color schemes that pertain to directional fields specifically. The drawing paradigm in Directional is that the visualization functions create actual meshes (vertices, faces, and per-face colors) for the different components of the field: box-like meshes for per-face glyphs representing vectors, sphere meshes for representing singularities, piecewise-cylinder curves to represent streamlines, and more. These visualization meshes can then be stored in libigl viewer as multiple meshes and visualized as needed.</p>
<p>The color schemes and directional visualization mesh creation functionality are mostly given in <a href="https://github.com/avaxman/Directional/tree/master/include/directional/visualization_schemes.h">visualization_schemes.h</a>, and can be called to create a homogeneous look for visualizing fields in applications. Most notable are <code class="codehilite">indexed_glyph_colors()</code> that gives back glyph meshes colored by index per face, and <code class="codehilite">default_singularity_colors()</code> that produces singularity meshes according to index. Other visualization functionality is detailed below in the context of the different examples.</p>
<h3 id="101-glyph-rendering">101 Glyph Rendering<a class="headerlink" href="#101-glyph-rendering" title="Permanent link">&para;</a></h3>
<p>The most basic operation on directional fields is reading them from a file and drawing them in the most explicit way. In <a href="https://github.com/avaxman/Directional/tree/master/tutorial/101_GlyphRendering/main.cpp">Example 101</a>, a field is read from a file as follows:</p>
<div class="codehilite"><pre><span></span><span class="n">directional</span><span class="o">::</span><span class="n">read_raw_field</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span> <span class="s">&quot;/bumpy.rawfield&quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">rawField</span><span class="p">);</span>
<span class="n">directional</span><span class="o">::</span><span class="n">read_singularities</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span> <span class="s">&quot;/bumpy.sings&quot;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">singVertices</span><span class="p">,</span> <span class="n">singIndices</span><span class="p">);</span>
</pre></div>

<p>The field is read in <em>raw</em> format (see <a href="https://github.com/avaxman/Directional/tree/master/file_formats">File Formats</a>), which is detailed in the <a href="#introduction">Introduction</a>. The field is <em>face-based</em>, and the singularities are consequently <em>vertex-based</em>, where <code class="codehilite">singVertices</code> are the singular vertices, and <code class="codehilite">singIndices</code> are the corresponding integer indices, so that the actual fractional indices are <span><span class="MathJax_Preview">\frac{singIndices}{N}</span><script type="math/tex">\frac{singIndices}{N}</script></span>.</p>
<p>The visualization meshes for the glyphs and the singularities are obtained as follows</p>
<div class="codehilite"><pre><span></span><span class="n">directional</span><span class="o">::</span><span class="n">glyph_lines_raw</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span> <span class="n">FMesh</span><span class="p">,</span> <span class="n">rawField</span><span class="p">,</span> <span class="n">directional</span><span class="o">::</span><span class="n">default_glyph_color</span><span class="p">(),</span> <span class="n">VField</span><span class="p">,</span> <span class="n">FField</span><span class="p">,</span> <span class="n">CField</span><span class="p">);</span>
<span class="n">directional</span><span class="o">::</span><span class="n">singularity_spheres</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span> <span class="n">FMesh</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">singVertices</span><span class="p">,</span> <span class="n">singIndices</span><span class="p">,</span> <span class="n">VSings</span><span class="p">,</span> <span class="n">FSings</span><span class="p">,</span> <span class="n">CSings</span><span class="p">);</span>
</pre></div>

<p>These two operations do not produce any active drawing; they create meshes that extend the original geometry, and then get passed to libigl viewer.</p>
<p><code class="codehilite">directional::glyph_lines_raw()</code> creates box-like meshes on the faces that constitute the <em>glyph drawing</em>: simply drawing the vectors upon the faces in their <span><span class="MathJax_Preview">\left(x,y,z\right)</span><script type="math/tex">\left(x,y,z\right)</script></span> coordinates, starting from the face barycenter. There are several possibilities to color these vectors, which can be local or global; check the documentation to the function in the header. In this case, we give the <code class="codehilite">default_glyph_color()</code> from the Directional visualization schemes. Vectors are drawn in their given magnitudes, up to a global scale. By default, this scale is set to be related to the average edge length&mdash;it can be manually set by all visualization-mesh-creating function.</p>
<p><code class="codehilite">directional::singularity_spheres()</code> creates a mesh of small spheres on vertices, where the size of the sphere is devised by default. The spheres are only created where the index is different than <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span>.</p>
<figure><img alt="Example 101 Glyph Rendering on a mesh, with singularities visible." src="../images/101_GlyphRendering.png" /><figcaption><a href="https://github.com/avaxman/Directional/tree/master/tutorial/101_GlyphRendering/main.cpp">Example 101</a> Glyph Rendering on a mesh, with singularities visible.</figcaption>
</figure>
<h3 id="102-picking-and-editing">102 Picking and editing<a class="headerlink" href="#102-picking-and-editing" title="Permanent link">&para;</a></h3>
<p>This tutorial demonstrates the editing paradigm in Directional, using libigl picking to make directional field editing possible. A face and a vector within the face are chosen, and clicking on a new direction for the vector changes it. Note the different setting of colors for glyphs: for the selected face and for the selected vector in the face particularly, via the following code in <a href="https://github.com/avaxman/Directional/tree/master/101_PickingEditing/main.cpp">Example 102</a>.</p>
<div class="codehilite"><pre><span></span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">glyphColors</span><span class="o">=</span><span class="n">directional</span><span class="o">::</span><span class="n">default_glyph_color</span><span class="p">().</span><span class="n">replicate</span><span class="p">(</span><span class="n">FMesh</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="n">N</span><span class="p">);</span>
<span class="n">glyphColors</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">currF</span><span class="p">)</span><span class="o">=</span><span class="n">directional</span><span class="o">::</span><span class="n">selected_face_glyph_color</span><span class="p">().</span><span class="n">replicate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
<span class="n">glyphColors</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="n">currF</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">currVec</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">=</span><span class="n">directional</span><span class="o">::</span><span class="n">selected_vector_glyph_color</span><span class="p">();</span>

<span class="n">directional</span><span class="o">::</span><span class="n">glyph_lines_raw</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span> <span class="n">FMesh</span><span class="p">,</span> <span class="n">rawField</span><span class="p">,</span> <span class="n">glyphColors</span><span class="p">,</span> <span class="n">VField</span><span class="p">,</span> <span class="n">FField</span><span class="p">,</span> <span class="n">CField</span><span class="p">);</span>
</pre></div>

<p>The selected face coloring is done as follows:</p>
<div class="codehilite"><pre><span></span><span class="n">CMesh</span><span class="o">=</span><span class="n">directional</span><span class="o">::</span><span class="n">default_mesh_color</span><span class="p">().</span><span class="n">replicate</span><span class="p">(</span><span class="n">FMesh</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="mi">1</span><span class="p">);</span>
<span class="n">CMesh</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">currF</span><span class="p">)</span><span class="o">=</span><span class="n">directional</span><span class="o">::</span><span class="n">selected_face_color</span><span class="p">();</span>
</pre></div>

<figure><img alt="(Example 102) Editing several vectors on a single face." src="../images/102_PickingEditing.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/102_PickingEditing/main.cpp">Example 102</a>) Editing several vectors on a single face.</figcaption>
</figure>
<h3 id="103-streamline-tracing">103 Streamline Tracing<a class="headerlink" href="#103-streamline-tracing" title="Permanent link">&para;</a></h3>
<p>Vector fields on surfaces are commonly visualized by tracing [streamlines] (<a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines</a>). Directional supports the seeding and tracing of streamlines, for all type of directionals. The seeds for the streamlines are initialized using <code class="codehilite">streamlines_init</code>, and the lines are traced using <code class="codehilite">streamlines_next</code>. Each call to <code class="codehilite">streamlines_next</code> extends each line by one triangle, allowing interactive rendering of the traced lines, as demonstrated in <a href="https://github.com/avaxman/Directional/tree/master/103_StreamlineTracing/main.cpp">Example 103</a>. The streamline are compiled into meshes with the following:</p>
<p><div class="codehilite"><pre><span></span>  <span class="n">directional</span><span class="o">::</span><span class="n">line_cylinders</span><span class="p">(</span><span class="n">sl_state</span><span class="p">.</span><span class="n">start_point</span><span class="p">,</span> <span class="n">sl_state</span><span class="p">.</span><span class="n">end_point</span><span class="p">,</span> <span class="mf">0.0005</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">replicate</span><span class="p">(</span><span class="n">sl_state</span><span class="p">.</span><span class="n">start_point</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="mi">1</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">VFieldNew</span><span class="p">,</span> <span class="n">FFieldNew</span><span class="p">,</span> <span class="n">CFieldNew</span><span class="p">);</span>
</pre></div>
creating meshes from many cylinders to have the appearance of continuous curves.</p>
<figure><img alt="(Example 103) Interactive streamlines tracing." src="../images/103_StreamlineTracing.gif" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/103_StreamlineTracing/main.cpp">Example 103</a>) Interactive streamlines tracing.</figcaption>
</figure>
<h2 id="chapter-2-discretization-and-representation">Chapter 2: Discretization and Representation<a class="headerlink" href="#chapter-2-discretization-and-representation" title="Permanent link">&para;</a></h2>
<p>In the following sections, we show some effects of working with different representations and converting between them.</p>
<h3 id="201-principal-matching">201 Principal Matching<a class="headerlink" href="#201-principal-matching" title="Permanent link">&para;</a></h3>
<p>One of the fundamental operations in directional-field processing is <em>matching</em>. That is, defining which vectors in face <span><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span> correspond to those in adjacent face <span><span class="MathJax_Preview">f_j</span><script type="math/tex">f_j</script></span>. In Directional, we only work with order-preserving matchings: if vector <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> in face <span><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span> is matched to vector <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> in face <span><span class="MathJax_Preview">f_j</span><script type="math/tex">f_j</script></span>, then for any <span><span class="MathJax_Preview">l</span><script type="math/tex">l</script></span>, <span><span class="MathJax_Preview">k+l</span><script type="math/tex">k+l</script></span> is matched to <span><span class="MathJax_Preview">m+l</span><script type="math/tex">m+l</script></span> (modulu <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>) in the respective faces. Suppose that the orientation of the dual edge is <span><span class="MathJax_Preview">f_i \rightarrow f_j</span><script type="math/tex">f_i \rightarrow f_j</script></span>, then the matching is encoded as <span><span class="MathJax_Preview">m-k</span><script type="math/tex">m-k</script></span>. Some representations, like rotation angles, already encode the matching explicitly, but others do not. Therefore, it needs to be devised from the field.</p>
<p>Given a raw field (in assumed CCW order in every face), it is possible to devise the rotation angles <span><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> by the process of <em>principal matching</em> <sup id="fnref:diamanti_2014"><a class="footnote-ref" href="#fn:diamanti_2014" rel="footnote">6</a></sup>. Principal matching creates the matching that minimizes the effort of the matching, always putting it within the range of <span><span class="MathJax_Preview">[-\pi, \pi)</span><script type="math/tex">[-\pi, \pi)</script></span> (and therefore denoted as &ldquo;principal&rdquo;). It corresponds to the &ldquo;smallest angle&rdquo; matching for <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy fields.</p>
<p>principal matching is done through the function <code class="codehilite">principal_matching()</code>  (from in <a href="https://github.com/avaxman/Directional/tree/master/201_PrincipalMatching/main.cpp">Example 201</a>) as follow:</p>
<p><div class="codehilite"><pre><span></span><span class="n">directional</span><span class="o">::</span><span class="n">principal_matching</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span> <span class="n">FMesh</span><span class="p">,</span><span class="n">EV</span><span class="p">,</span> <span class="n">EF</span><span class="p">,</span> <span class="n">FE</span><span class="p">,</span> <span class="n">rawField</span><span class="p">,</span> <span class="n">matching</span><span class="p">,</span> <span class="n">effort</span><span class="p">);</span>
<span class="n">directional</span><span class="o">::</span><span class="n">effort_to_indices</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span><span class="n">FMesh</span><span class="p">,</span><span class="n">EV</span><span class="p">,</span> <span class="n">EF</span><span class="p">,</span> <span class="n">effort</span><span class="p">,</span><span class="n">matching</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">singVertices</span><span class="p">,</span><span class="n">singIndices</span><span class="p">);</span>
</pre></div>
<code class="codehilite">directional::effort_to_indices()</code> computes the <i>index</i> of each vertex from the effort around it. The index of a vertex is the amount of rotations a directional object undergoes along a cycle around the vertex. a directional must return to itself after a cycle, and therefore the index is an integer <span><span class="MathJax_Preview">I</span><script type="math/tex">I</script></span> when a vector <span><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> in the face ended up in vector <span><span class="MathJax_Preview">m+I</span><script type="math/tex">m+I</script></span>. Note that this can also include multiple full rotations(so: this is <em>not</em> taken modulu <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>), where the index is unbounded. The <em>fractional</em> part of the index is encoded by the matching; however, matching alone cannot encode <em>integral</em> indices (for instance, a single vector field has trivial (Zero) matching anywhere, but can have singularities). <code class="codehilite">singVertices</code> and <code class="codehilite">singIndices</code> only enumerate the singular vertices.</p>
<figure><img alt="(Example 201) A Field is shown with singularities, and a single face is shown with the principal matching to its neighbors (in multiple colors)." src="../images/201_PrincipalMatching.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/201_PrincipalMatching/main.cpp">Example 201</a>) A Field is shown with singularities, and a single face is shown with the principal matching to its neighbors (in multiple colors).</figcaption>
</figure>
<h3 id="202-sampling">202 Sampling<a class="headerlink" href="#202-sampling" title="Permanent link">&para;</a></h3>
<p>This is an educatory example that demonstrates the loss of information when moving between a polar (in this case, rotation angle) representation, to a Cartesian representation, where the matching between vectors in adjacent faces is done with principal matching. In that case, low valence cycles and undersampling cause aliasing in the perceived field. There are three modes seen in the example:</p>
<ol>
<li>
<p>In the polar mode, the user can prescrube the index of a singularity directly. With this, the rotation angles between adjacent faces become arbitrarily large, and appear as noise in the low valence cycles.</p>
</li>
<li>
<p>In the principal matching mode, the rotations are recoconstructed from the field, without prior knowledge of the polar-prescribed rotations from the previous mode. The noise of the field then gives rise to a &ldquo;singularity party&rdquo;.</p>
</li>
<li>
<p>In the Cartesian mode, the field is interpolated on the free faces (white) from the constrained faces (red), keeping the red band fixed from the polar mode. We see a field that in smooth in the Cartesian sense, with more uniformly dispersed singularities.</p>
</li>
</ol>
<figure><img alt="(Example 202) Animating: the polar mode, the principal matching mode, and the Cartesian mode." src="../images/202_Sampling.gif" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/202_Sampling/main.cpp">Example 202</a>) Animating: the polar mode, the principal matching mode, and the Cartesian mode.</figcaption>
</figure>
<h3 id="203-combing">203 Combing<a class="headerlink" href="#203-combing" title="Permanent link">&para;</a></h3>
<p>Given a matching (in this case, principal matching), it is possible to &ldquo;comb&rdquo; the field. That is, re-index each face (keeping the CCW order), so that the vector indexing aligns perfectly with the matching to the neighbors&mdash;then, the new matching on the dual edges becomes trivially zero. This operation is important in order to prepare a directional field for integration, for instance. In the presence of singularities, the field can only be combed up to a set of connected paths that connect between singularities, also known as <em>seams</em>. Note that such paths do not necessarily the mesh to a simply-connected patch, but only connects subgroups with indices adding up to an integer; as a trivial example, a 1-vector field is trivially combed to begin with, even in the presence of its (integral) singularities, and the set of seams is zero. The combing is done through the function <code class="codehilite">directional::combing()</code> as follows, taken from <a href="https://github.com/avaxman/Directional/tree/master/203_Combing/main.cpp">Example 203</a></p>
<div class="codehilite"><pre><span></span><span class="n">directional</span><span class="o">::</span><span class="n">combing</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span><span class="n">FMesh</span><span class="p">,</span> <span class="n">EV</span><span class="p">,</span> <span class="n">EF</span><span class="p">,</span> <span class="n">FE</span><span class="p">,</span> <span class="n">rawField</span><span class="p">,</span> <span class="n">matching</span><span class="p">,</span> <span class="n">combedField</span><span class="p">);</span>
</pre></div>

<p>where <code class="codehilite">combedField</code> is the re-indexed <code class="codehilite">rawField</code>, done according to the matching. We can re-do the matching on the combed field to retrieve the seams:</p>
<div class="codehilite"><pre><span></span><span class="n">directional</span><span class="o">::</span><span class="n">principal_matching</span><span class="p">(</span><span class="n">VMesh</span><span class="p">,</span> <span class="n">FMesh</span><span class="p">,</span><span class="n">EV</span><span class="p">,</span> <span class="n">EF</span><span class="p">,</span> <span class="n">FE</span><span class="p">,</span> <span class="n">combedField</span><span class="p">,</span> <span class="n">combedMatching</span><span class="p">,</span> <span class="n">combedEffort</span><span class="p">);</span>
</pre></div>

<figure><img alt="(Example 203) Vector indices inside each face are colored, combed (with seams) and uncombed)." src="../images/203_Combing.gif" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/203_Combing/main.cpp">Example 203</a>) Vector indices inside each face are colored, combed (with seams) and uncombed).</figcaption>
</figure>
<h2 id="chapter-3-cartesian-methods">Chapter 3: Cartesian Methods<a class="headerlink" href="#chapter-3-cartesian-methods" title="Permanent link">&para;</a></h2>
<h3 id="cartesian-fields">Cartesian Fields<a class="headerlink" href="#cartesian-fields" title="Permanent link">&para;</a></h3>
<p>The Cartesian representation is a meta-category for representation of vectors in explicit coordinates, either <span><span class="MathJax_Preview">\left(x,y\right)</span><script type="math/tex">\left(x,y\right)</script></span> in some local <span><span class="MathJax_Preview">2D</span><script type="math/tex">2D</script></span> basis on a tangent plane, or <span><span class="MathJax_Preview">\left(x,y,z\right)</span><script type="math/tex">\left(x,y,z\right)</script></span> in the ambient coordinates of space. The raw, representative (of an <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy), power field, and PolyVector representations are all such examples. Cartesian fields often do not automatically contain information about the matching, or rotation, of a field between one face and the next, and it needs to be computed using principal matching. This chapter focuses on computing fields with this representation.</p>
<h3 id="301-power-fields">301 Power Fields<a class="headerlink" href="#301-power-fields" title="Permanent link">&para;</a></h3>
<p>This representation is offered in <sup id="fnref:knoppel_2013"><a class="footnote-ref" href="#fn:knoppel_2013" rel="footnote">10</a></sup>, but they did not give it a specific name (the method in general is called &ldquo;globally optimal&rdquo;). We use the name &ldquo;power fields&rdquo; given in <sup id="fnref:azencot_2017"><a class="footnote-ref" href="#fn:azencot_2017" rel="footnote">1</a></sup>.</p>
<p>A power field representation uses a complex basis in each tangent plane (face in our implementation), and represents an <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy using a <em>power vector</em>&mdash;a single complex number <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> per face so that its root set <span><span class="MathJax_Preview">y=u^N</span><script type="math/tex">y=u^N</script></span> comprises the vectors of the <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy.</p>
<p>By prescribing constraints <span><span class="MathJax_Preview">y_B</span><script type="math/tex">y_B</script></span> on a set of faces <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>, the algorithm interpolates the field to the rest of the faces <span><span class="MathJax_Preview">y_I</span><script type="math/tex">y_I</script></span> by minimizing the face-based Dirichlet energy:</p>
<div>
<div class="MathJax_Preview">y_I=\text{argmin}\sum_{e=(f,g)\in F \times F}{\left|y_fe_f^N - y_ge_g^N\right|^2},</div>
<script type="math/tex; mode=display">y_I=\text{argmin}\sum_{e=(f,g)\in F \times F}{\left|y_fe_f^N - y_ge_g^N\right|^2},</script>
</div>
<p>where <span><span class="MathJax_Preview">e_f</span><script type="math/tex">e_f</script></span> is the representation of the vector of edge <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span> in the basis of <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>, and <span><span class="MathJax_Preview">e_g</span><script type="math/tex">e_g</script></span> is for <span><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span> respectively. The field is computed through the function <code class="codehilite">directional::power_field()</code>.</p>
<p>For fixed set <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> and changing <span><span class="MathJax_Preview">y_B</span><script type="math/tex">y_B</script></span>, It is possible to speed up computations by precomputing the solver (sparse Cholsky for the positive-definite matrix) used to compute the power field. This is done by using the function <code class="codehilite">directional::power_field_precompute()</code>, coupled with the appropriate version of <code class="codehilite">directional::power_field()</code>. Note that field can be converted to representative and raw forms using the appropriate <code class="codehilite">power_to_X</code> functions.</p>
<p>If the set <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is empty, then the computed field is the first Eigenvector of the Dirichlet energy.</p>
<figure><img alt="(Example 301) Setting up a small subset of constraints (red faces), and interpolating (and normalizing in magnitude) the power field to the rest of the mesh. Note the singularities that are discovered through principal matching." src="../images/301_PowerFields.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/301_PowerFields/main.cpp">Example 301</a>) Setting up a small subset of constraints (red faces), and interpolating (and normalizing in magnitude) the power field to the rest of the mesh. Note the singularities that are discovered through principal matching.</figcaption>
</figure>
<h3 id="302-polyvectors">302 PolyVectors<a class="headerlink" href="#302-polyvectors" title="Permanent link">&para;</a></h3>
<p>A Polyvector field <sup id="fnref2:diamanti_2014"><a class="footnote-ref" href="#fn:diamanti_2014" rel="footnote">6</a></sup> is a generalization of power fields that allows to represent independent vectors in each tangent plane. The representation is as the coefficient set <span><span class="MathJax_Preview">a_{0 \cdots N-1}</span><script type="math/tex">a_{0 \cdots N-1}</script></span> of a monic complex polynomial in the local compex basis:</p>
<div>
<div class="MathJax_Preview">P(z) = a_0 + a_1z + \ldots + a_{N-1} z^{N-1} + z^N,</div>
<script type="math/tex; mode=display">P(z) = a_0 + a_1z + \ldots + a_{N-1} z^{N-1} + z^N,</script>
</div>
<p>where the roots <span><span class="MathJax_Preview">P(z)=0</span><script type="math/tex">P(z)=0</script></span> are the vectors of the face-based directional object, represented as complex numbers in the local basis. The Dirichlet energy is as for power fields, except with a term for each <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span>, with the appropriate power <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>. Note that an <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-RoSy is represented as a polynomial where all <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> are zero except <span><span class="MathJax_Preview">a_0</span><script type="math/tex">a_0</script></span>. Principal matching, combing, and effort are well-defined on PolyVectors as well.</p>
<p><a href="https://github.com/avaxman/Directional/tree/master/302_PolyVectors/main.cpp">Example 302</a> allows a user to set individual vectors within each face, and see the interpolated result. The responsible function is <code class="codehilite">directional::polyvector_field()</code>. In this case as well, the solver can be prefactored in advance using <code class="codehilite">directional::polyvector_precompute()</code>.</p>
<figure><img alt="(Example 302) Vectors are constrained individually in the constrained faces (red), and interpolated to the rest of the faces" src="../images/302_PolyVectors.png" /><figcaption>(<a href="302_PolyVectors/main.cpp">Example 302</a>) Vectors are constrained individually in the constrained faces (red), and interpolated to the rest of the faces</figcaption>
</figure>
<h3 id="303-polycurl-reduction">303 PolyCurl Reduction<a class="headerlink" href="#303-polycurl-reduction" title="Permanent link">&para;</a></h3>
<p>Vector-field guided surface parameterization is based on the idea of designing the <em>candidate</em> gradients
of the parameterization functions (which are tangent vector fields on the surface) instead of the functions themselves. Thus, vector-set fields (<span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-Rosy, frame fields, and polyvector fields) that are to be used for parameterization (and subsequent remeshing) need to be <em>integrable</em>: it must be possible to locally break them down into individual vector fields that are gradients of scalar functions. Fields obtained by &ldquo;as-smooth-as-possible&rdquo; design methods (eg. <sup id="fnref:ray_2008"><a class="footnote-ref" href="#fn:ray_2008" rel="footnote">11</a></sup>, <sup id="fnref2:knoppel_2013"><a class="footnote-ref" href="#fn:knoppel_2013" rel="footnote">10</a></sup>, <sup id="fnref3:diamanti_2014"><a class="footnote-ref" href="#fn:diamanti_2014" rel="footnote">6</a></sup>, <sup id="fnref:bommes_2009"><a class="footnote-ref" href="#fn:bommes_2009" rel="footnote">2</a></sup>, <sup id="fnref:panozzo_2014"><a class="footnote-ref" href="#fn:panozzo_2014" rel="footnote">15</a></sup>) do not have this property in general. In <sup id="fnref:diamanti_2015"><a class="footnote-ref" href="#fn:diamanti_2015" rel="footnote">7</a></sup>, a method for creating integrable polyvector fields was introduced by the process of <em>curl-reduction</em>. This method takes as input a given field and improves its integrability by iteratively reducing the <em>PolyCurl</em> of the field; that is, the coefficients of a dual-edge-based polynomial, whose roots are the curl of the matched vectors of both respective adjacent faces. By working with PolyCurl instead of matching, the optimization can be done on the POlyVector itself, allowing for singularities to naturally move around. However, the optimization is nonlinear&mdash;it reduces the PolyCurl iteratively, while preserving the CCW order of the vectors for a bijective parameterization, and keeping it as smooth and orthogonal as possible for quality results.</p>
<p>A field that has zero PolyCurl everywhere is locally (away from singularities) integrable into <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> different scalar functions; globally, it is integrable into a <em>rotationally-seamless</em> multi-branched function, which we further demonstrate in <a href="#chapter-5-seamless-parameterization">Chapter 5</a>. In <a href="https://github.com/avaxman/Directional/tree/master/303_PolyCurlReduction/main.cpp">Example 303</a> we demonstrate the optimization for curl.</p>
<figure><img alt="(Example 303) PolyCurl is iterative reduced from an initial PolyVector field, Top: fields for iteration 0 (original), 10, and 50. Bottom: PolyCurl plots. The color is the norm of the vector of the roots of the PolyCurl. Its maximal value (infinity norm) appears below." src="../images/303_PolyCurlReduction.png" /><figcaption>(<a href="303_PolyCurlReduction/main.cpp">Example 303</a>) PolyCurl is iterative reduced from an initial PolyVector field, Top: fields for iteration 0 (original), 10, and 50. Bottom: PolyCurl plots. The color is the norm of the vector of the roots of the PolyCurl. Its maximal value (infinity norm) appears below.</figcaption>
</figure>
<h3 id="304-conjugate-fields">304 Conjugate Fields<a class="headerlink" href="#304-conjugate-fields" title="Permanent link">&para;</a></h3>
<p>Two tangent vectors <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> and <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> are conjugate if</p>
<p>$$k_1 (u^T d_1)(v^T d_1) + k_2(u^T d_2)(v^T d_2) = 0. $$,
where <span><span class="MathJax_Preview">k_1</span><script type="math/tex">k_1</script></span> and <span><span class="MathJax_Preview">k_2</span><script type="math/tex">k_2</script></span> are the principal curvatures and <span><span class="MathJax_Preview">d_1</span><script type="math/tex">d_1</script></span> and <span><span class="MathJax_Preview">d_2</span><script type="math/tex">d_2</script></span> are the respective principal directions.</p>
<p>Conjugate vector fields are very important in computational geometry: their integral lines form, informally speaking, an infinitesimal planar quad mesh. As such, the finite quad mesh that result out of integrating these fields is considered as a good candidate for consequent planarity parameterization <sup id="fnref:liu_2011"><a class="footnote-ref" href="#fn:liu_2011" rel="footnote">12</a></sup>.</p>
<p>Finding a conjugate vector field that satisfies given directional constraints is a standard problem in architectural geometry, which can be tackled by
deforming a <span><span class="MathJax_Preview">2^2</span><script type="math/tex">2^2</script></span> PolyVector field to the closest conjugate field. Such an algorithm was presented in <sup id="fnref4:diamanti_2014"><a class="footnote-ref" href="#fn:diamanti_2014" rel="footnote">6</a></sup>, which alternates beweetn a global smoothness and orthogonality step, and a local step that projects the field on every face to the closest conjugate field (<a href="https://github.com/avaxman/Directional/tree/master/304_ConjugateField/main.cpp">Example 304</a>).</p>
<figure><img alt="(Example 304) A smooth 2^22^2-PolyVector field (left) is deformed to become a conjugate field (right). Top: fields Bottom: conjugacy plots." src="../images/304_ConjugateFields.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/304_ConjugateFields/main.cpp">Example 304</a>) A smooth <span><span class="MathJax_Preview">2^2</span><script type="math/tex">2^2</script></span>-PolyVector field (left) is deformed to become a conjugate field (right). Top: fields Bottom: conjugacy plots.</figcaption>
</figure>
<h2 id="chapter-4-polar-methods">Chapter 4: Polar Methods<a class="headerlink" href="#chapter-4-polar-methods" title="Permanent link">&para;</a></h2>
<h3 id="polar-fields">Polar Fields<a class="headerlink" href="#polar-fields" title="Permanent link">&para;</a></h3>
<p>Polar fields are represented using angles. These angles may encode the rotation from some known basis on a tangent plane (and so it is a &ldquo;logarithmic&rdquo; representation, when compared to Cartesian methods), or an angle difference between two neighboring tangent planes (in the sense of deviation from parallel transport). The former usually requires integer variables for directional field design. The latter does not, but state-of-the-art methods require the prescription of indices around independent dual cycles in the mesh. Currently, Directional supports the latter.</p>
<h3 id="401-index-prescription">401 Index Prescription<a class="headerlink" href="#401-index-prescription" title="Permanent link">&para;</a></h3>
<p>The notion of encoding rotation angles on dual edges, as means to encode deviation from parallel transport between adjacent tangent planes, appeared in several formats in the literature <sup id="fnref2:ray_2008"><a class="footnote-ref" href="#fn:ray_2008" rel="footnote">11</a></sup>, <sup id="fnref:crane_2010"><a class="footnote-ref" href="#fn:crane_2010" rel="footnote">5</a></sup>. The formulation and notation we use in Directional is that of Trivial Connections <sup id="fnref2:crane_2010"><a class="footnote-ref" href="#fn:crane_2010" rel="footnote">5</a></sup>. Trivial connection solves for a single rotation angle <span><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> per (dual) edge <span><span class="MathJax_Preview">e_{ij}</span><script type="math/tex">e_{ij}</script></span> between two faces <span><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span> and <span><span class="MathJax_Preview">f_j</span><script type="math/tex">f_j</script></span>, encoding the deviation from parallel transport between them. The algorithm first computes a spanning set of <em>basis cycles</em>, around all of which the sum of <span><span class="MathJax_Preview">\delta_{ij}</span><script type="math/tex">\delta_{ij}</script></span> has to be prescribed. The summation is defined as a matrix <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>. Every such cycle (row in the matrix) has a curvature, defined as a discrete angle defect, and the prescribed index defines an alternative curvature. The algorithm solves for the smoothest field, in the 2-norm least squares sense, as follows:</p>
<div>
<div class="MathJax_Preview">
\delta = \text{argmin}\ |\delta_{ij}|^2\ s.t.\ H\delta = -K_0 + K.
</div>
<script type="math/tex; mode=display">
\delta = \text{argmin}\ |\delta_{ij}|^2\ s.t.\ H\delta = -K_0 + K.
</script>
</div>
<p><span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> is the matrix that defines the basis-cycles sum, <span><span class="MathJax_Preview">K_0</span><script type="math/tex">K_0</script></span> is a vector of the original curvatures of every basis cycle, and <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> is the prescribed curvature. <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> defines the prescribed singularity indices: for regular cycles, we prescribe <span><span class="MathJax_Preview">K=0</span><script type="math/tex">K=0</script></span>, and for a singular cycle with prescribed singularity index <span><span class="MathJax_Preview">\frac{i}{N}</span><script type="math/tex">\frac{i}{N}</script></span>, we set <span><span class="MathJax_Preview">K=\frac{2\pi i}{N}</span><script type="math/tex">K=\frac{2\pi i}{N}</script></span>. the sum of <span><span class="MathJax_Preview">K</span><script type="math/tex">K</script></span> has to conform to the Poincar&eacute; index theorem, except generator (handle) cycles that admit unbounded indices. See <sup id="fnref3:crane_2010"><a class="footnote-ref" href="#fn:crane_2010" rel="footnote">5</a></sup> for exact details. If the input obeys the sum, the result obeys the prescribed indices around the cycles everywhere. The representation is <em>differential</em>, and there is then a global degree of freedom in setting a single direction in a single arbitrary face.</p>
<p>Note that the correct definition for &ldquo;cycle curvature&rdquo; corresponds to the so-called &ldquo;cycle holonomy&rdquo;, only up to integer multiples of <span><span class="MathJax_Preview">2\pi</span><script type="math/tex">2\pi</script></span>. However, in the discrete setting, the curvature should theoretically be computed as the exact discrete angle defect, in which for inner vertices we use <span><span class="MathJax_Preview">2\pi-\sum{\alpha}</span><script type="math/tex">2\pi-\sum{\alpha}</script></span>, and for boundary vertices we use <span><span class="MathJax_Preview">\pi - \sum{\alpha}</span><script type="math/tex">\pi - \sum{\alpha}</script></span> (<span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> are the angles at the corners of a vertex). For a cycle aggregating many vertices, such as a boundary-loop cycle, we add up all the defects. That is required for exact discrete Poincar&eacute; index consistency. Note that the boundary indices define how many rotations of the vector field the boundary loop &ldquo;sees&rdquo;. As an example, a constant field on a simple disc in the plane has all indices <span><span class="MathJax_Preview">0</span><script type="math/tex">0</script></span> inside, but the boundary index is in fact <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>&mdash;This obeys the total index sum <span><span class="MathJax_Preview">\chi = 2-2g-b = 2-0-1=1</span><script type="math/tex">\chi = 2-2g-b = 2-0-1=1</script></span> (<span><span class="MathJax_Preview">g</span><script type="math/tex">g</script></span> stands for genus and <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> for number of boundary loops)</p>
<h4 id="basis-cycles">Basis Cycles<a class="headerlink" href="#basis-cycles" title="Permanent link">&para;</a></h4>
<p>The basis cycles form the cycles around which curvatures (and singularities) have to be prescribed on the mesh. The sum on basis cycles is described in a sparse matrix <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> of size <span><span class="MathJax_Preview">|cycles|\times |E_I|</span><script type="math/tex">|cycles|\times |E_I|</script></span>, where <span><span class="MathJax_Preview">E_I</span><script type="math/tex">E_I</script></span> is the number of inner edges in the mesh. Each row in the matrix describes the sum over one cycle, and contains <span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> or <span><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> values depending on the (arbitrary) orientation of the dual edge participating in the cycle to the respective face. There are three types of cycles, so ordered in the rows of <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>:</p>
<ol>
<li><span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span>-ring dual cycles around each inner vertex, on which vertex-based singularities can be encoded (the relevant part of <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> is basically <span><span class="MathJax_Preview">\left(d_0\right)^T</span><script type="math/tex">\left(d_0\right)^T</script></span> in discrete exterior calculus, restricted to inner edges).</li>
<li>Cycles around mesh boundary loops.</li>
<li>Cycles around the <span><span class="MathJax_Preview">2g</span><script type="math/tex">2g</script></span> topological generators (independent handles).</li>
</ol>
<p>The method <code class="codehilite">directional::dual_cycles()</code> computes the proper basis cycles and matrix <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span>. To be able to intuitively prescribe singularities to inner vertices, the method also returns a conversion vector <code class="codehilite">vertex2cycle</code>, and the list of indices of inner edges from the list of edges.</p>
<p>The singularity indices that are prescribed contain the singularity index corresponding to each basis cycle. A value of <span><span class="MathJax_Preview">k \in \mathbb{Z}</span><script type="math/tex">k \in \mathbb{Z}</script></span> represents an <span><span class="MathJax_Preview">\frac{2\pi k}{N}</span><script type="math/tex">\frac{2\pi k}{N}</script></span> rotation around the respective cycle. If the prescribed indices do not conform to the Poincar&eacute; index theorem, a result will still be computed by least squares, but it will be unpredictable. The algorithm is performed through the function <code class="codehilite">directional::index_prescription()</code>, which can also accept a solver for precomputation, for the purpose of prefactoring <span><span class="MathJax_Preview">H</span><script type="math/tex">H</script></span> only once.</p>
<figure><img alt="(Example 401) Indices are prescribed on several vertex singularities, and on a generator loop, to match the index theorem." src="../images/401_IndexPrescription.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/401_IndexPrescription/main.cpp">Example 401</a>) Indices are prescribed on several vertex singularities, and on a generator loop, to match the index theorem.</figcaption>
</figure>
<h2 id="chapter-5-seamless-parameterization">Chapter 5: Seamless Parameterization<a class="headerlink" href="#chapter-5-seamless-parameterization" title="Permanent link">&para;</a></h2>
<p>Directional fields are commonly used to create seamless parameterizations <sup id="fnref2:bommes_2009"><a class="footnote-ref" href="#fn:bommes_2009" rel="footnote">2</a></sup>,<sup id="fnref:Kaelberer_2007"><a class="footnote-ref" href="#fn:Kaelberer_2007" rel="footnote">9</a></sup>,<sup id="fnref:Myles_2014"><a class="footnote-ref" href="#fn:Myles_2014" rel="footnote">13</a></sup>. Recall that <a href="#203-combing">combing</a> trivializes the matching everywhere but a sparse set of seams. We augment these seams so that the mesh is cut into disc topology. Then, we treat a combed <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-directional <span><span class="MathJax_Preview">\left\{v_0,\cdots,v_{N-1}\right\}</span><script type="math/tex">\left\{v_0,\cdots,v_{N-1}\right\}</script></span> as a set of candidate gradients for <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span> vertex-based functions <span><span class="MathJax_Preview">\left\{F_0,\cdots,F_{N-1}\right\}</span><script type="math/tex">\left\{F_0,\cdots,F_{N-1}\right\}</script></span> on the cut mesh. On the cut mesh, we then solve the Poisson problem:</p>
<p>$$ F = argmin{\sum_{i=0}^{N-1}{\left|\nabla F_i - v_i\right|^2}} $$.</p>
<p>Consider a seam edge <span><span class="MathJax_Preview">e_{ij}</span><script type="math/tex">e_{ij}</script></span> between original vertices <span><span class="MathJax_Preview">v_i</span><script type="math/tex">v_i</script></span> and <span><span class="MathJax_Preview">v_j</span><script type="math/tex">v_j</script></span>, and between adjacent faces <span><span class="MathJax_Preview">f_k</span><script type="math/tex">f_k</script></span> and <span><span class="MathJax_Preview">f_l</span><script type="math/tex">f_l</script></span>. The two vertices are then cut into four corners <span><span class="MathJax_Preview">v_{i,k},v_{j,k},v_{i,l},v_{j,l}</span><script type="math/tex">v_{i,k},v_{j,k},v_{i,l},v_{j,l}</script></span>. Note that some corners might be identical, if the seam edge is at a singularity. across the seam edge, we enforce the (linear) seamless conditions:</p>
<div>
<div class="MathJax_Preview">F_{i,k}= \pi_e \cdot F_{i,l}  + T_e,</div>
<script type="math/tex; mode=display">F_{i,k}= \pi_e \cdot F_{i,l}  + T_e,</script>
</div>
<p>where <span><span class="MathJax_Preview">\pi_e:N \times N</span><script type="math/tex">\pi_e:N \times N</script></span> is a permutation matrix attached to the (dual) edge <span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>, matching values in the integrated function <span><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span> as it did for the directional field <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>. and <span><span class="MathJax_Preview">T_e:N \times 1</span><script type="math/tex">T_e:N \times 1</script></span> is a <em>translational jump</em> (also: period jump), that encodes the discontinuity in <span><span class="MathJax_Preview">F</span><script type="math/tex">F</script></span> across the seam. For quick intuition, this encodes the integration of the function over a loop around the mesh beginning and ending with the seam edge: in a quad-mesh parameterization, it is the number of quads in such a loop.</p>
<p>Every parameterization that obeys the seamless constraint is seamless; it can be easily shown <sup id="fnref2:Kaelberer_2007"><a class="footnote-ref" href="#fn:Kaelberer_2007" rel="footnote">9</a></sup> that the translational jump <span><span class="MathJax_Preview">T_e</span><script type="math/tex">T_e</script></span> is in fact uniform across seam curves between singularities. Thus, the amount of such jumps is the number of seam curves in the mesh.</p>
<h3 id="501-seamless-parameterization">501 Seamless Parameterization<a class="headerlink" href="#501-seamless-parameterization" title="Permanent link">&para;</a></h3>
<p>In <a href="https://github.com/avaxman/Directional/tree/master/501_SeamlessParameterization/main.cpp">Example 501</a> we demonstrate the computation of such a parameterization. The core functionality is in these lines:</p>
<div class="codehilite"><pre><span></span><span class="n">directional</span><span class="o">::</span><span class="n">ParameterizationData</span> <span class="n">pd</span><span class="p">;</span>
<span class="n">directional</span><span class="o">::</span><span class="n">cut_mesh_with_singularities</span><span class="p">(</span><span class="n">VMeshWhole</span><span class="p">,</span> <span class="n">FMeshWhole</span><span class="p">,</span> <span class="n">singVertices</span><span class="p">,</span> <span class="n">pd</span><span class="p">.</span><span class="n">face2cut</span><span class="p">);</span>
  <span class="p">...</span>
<span class="n">directional</span><span class="o">::</span><span class="n">setup_parameterization</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">VMeshWhole</span><span class="p">,</span> <span class="n">FMeshWhole</span><span class="p">,</span>  <span class="n">EV</span><span class="p">,</span> <span class="n">EF</span><span class="p">,</span> <span class="n">FE</span><span class="p">,</span> <span class="n">combedMatching</span><span class="p">,</span> <span class="n">singVertices</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">VMeshCut</span><span class="p">,</span> <span class="n">FMeshCut</span><span class="p">);</span>
 <span class="kt">double</span> <span class="n">lengthRatio</span><span class="o">=</span><span class="mf">0.01</span><span class="p">;</span>
 <span class="kt">bool</span> <span class="n">isInteger</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">//do not do translational seamless.</span>
 <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Solving parameterization&quot;</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
 <span class="n">directional</span><span class="o">::</span><span class="n">parameterize</span><span class="p">(</span><span class="n">VMeshWhole</span><span class="p">,</span> <span class="n">FMeshWhole</span><span class="p">,</span> <span class="n">FE</span><span class="p">,</span> <span class="n">combedField</span><span class="p">,</span> <span class="n">lengthRatio</span><span class="p">,</span> <span class="n">pd</span><span class="p">,</span> <span class="n">VMeshCut</span><span class="p">,</span> <span class="n">FMeshCut</span><span class="p">,</span> <span class="n">isInteger</span><span class="p">,</span> <span class="n">cutUV</span><span class="p">);</span>
</pre></div>

<p><code class="codehilite">directional::cut_mesh_with_singularities()</code> encodes the the seams in <code class="codehilite">pd.face2cut</code>. <code class="codehilite">directional::setup_parameterization()</code> creates the Poisson system and the constraints, and creates the actual cut mesh in <code class="codehilite">VMeshCut</code> and <code class="codehilite">FMeshCut</code>.  <code class="codehilite">directional::parameterize()</code> solves the parameterization, and puts the result in <code class="codehilite">cutUV</code>. The functionality is currently limited only to <span><span class="MathJax_Preview">2^2</span><script type="math/tex">2^2</script></span> fields (<span><span class="MathJax_Preview">N=4</span><script type="math/tex">N=4</script></span>) with symmetry assumed. <code class="codehilite">lengthRatio</code> encodes a global scale for the Poisson problem (scaling the fields uniformly), where the ratio is measured against the bounding box diagonal.</p>
<p>The variable <code class="codehilite">isInteger</code> refers set to <code class="codehilite">false</code> which means that the parameterization would only be <em>rotationally-seamless</em>; the appearance across the seams would align only in direction. The next example considers the stronger option.</p>
<figure><img alt="(Example 501) Left: directional field. Right: rotationally-seamless parameterization. Note that the direction of the texture aligns across seams." src="../images/501_SeamlessParameterization.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/501_SeamlessParameterization/main.cpp">Example 501</a>) Left: directional field. Right: rotationally-seamless parameterization. Note that the direction of the texture aligns across seams.</figcaption>
</figure>
<h3 id="502-mixed-integer-parametrization">502 Mixed-Integer Parametrization<a class="headerlink" href="#502-mixed-integer-parametrization" title="Permanent link">&para;</a></h3>
<p>To use seamless parameterizations for the purpose of quad meshing, we require the texture to be <em>fully-seamless</em> across seams. With this, the seams are virtually invisible on the cut mesh. This can be done by setting all <span><span class="MathJax_Preview">T_e</span><script type="math/tex">T_e</script></span> to values in <span><span class="MathJax_Preview">2\mathbb{Z}</span><script type="math/tex">2\mathbb{Z}</script></span> (for why double integers are necessary, see <sup id="fnref3:Kaelberer_2007"><a class="footnote-ref" href="#fn:Kaelberer_2007" rel="footnote">9</a></sup>). The solving is done by simple iterative rounding [^Bommes_2009]: we choose the value in <span><span class="MathJax_Preview">T_e</span><script type="math/tex">T_e</script></span> which is the closest to a double integer, round and fix it, and repeat until all <span><span class="MathJax_Preview">T_e</span><script type="math/tex">T_e</script></span> are rounded. Note that CoMISo <sup id="fnref:Bommes_2012"><a class="footnote-ref" href="#fn:Bommes_2012" rel="footnote">3</a></sup> has a more sophisticated Gauss-Seidel rounding algorithm that is more efficient; however, we include an implementation in Directional to avoid the dependency, and since this will be used for general <span><span class="MathJax_Preview">N</span><script type="math/tex">N</script></span>-function parameterization in future versions of Directional.</p>
<p>Mixed-integer parameterization is demonstrated in <a href="https://github.com/avaxman/Directional/tree/master/502_MixedIntegerParameterization/main.cpp">Example 502</a>. The essential difference from <a href="https://github.com/avaxman/Directional/tree/master/501_SeamlessParameterization/main.cpp">Example 501</a> is by simply setting <code class="codehilite">isInteger=true</code>, when passed to <code class="codehilite">directional::parameterize()</code>.</p>
<p><em>Note:</em> The input field <code class="codehilite">horsers-cf.rawfield</code> is computed according to <a href="#303-polycurl-reduction">Example 303</a> to have negligible PolyCurl. As such, the rotationally-seamless parameterization has a very low error (<span><span class="MathJax_Preview">L_\infty</span><script type="math/tex">L_\infty</script></span> of <span><span class="MathJax_Preview">1.25778\cdot 10^{-5})</span><script type="math/tex">1.25778\cdot 10^{-5})</script></span>). The rounding iterations incur some error, but it is rather low as well (after rounding <span><span class="MathJax_Preview">116</span><script type="math/tex">116</script></span> variables it climbs to <span><span class="MathJax_Preview">L_\infty=0.657496</span><script type="math/tex">L_\infty=0.657496</script></span>); we therefore recommend to warm-start a mixed-integer parameterization with a curl-reduced directional field.</p>
<figure><img alt="(Example 502) Top Left: directional field. Top right: rotationally-seamless parameterization. Bottom: fully-seamless parameterization." src="../images/502_MixedIntegerParameterization.png" /><figcaption>(<a href="https://github.com/avaxman/Directional/tree/master/502_MixedIntegerParameterization/main.cpp">Example 502</a>) Top Left: directional field. Top right: rotationally-seamless parameterization. Bottom: fully-seamless parameterization.</figcaption>
</figure>
<h2 id="outlook-for-continuing-development">Outlook for continuing development<a class="headerlink" href="#outlook-for-continuing-development" title="Permanent link">&para;</a></h2>
<p>Directional is a budding project, and there are many algorithms in the state-of-the-art that we look forward to implement, with the help of volunteer researchers and practitioners from the field. Prominent examples of desired implementations are:</p>
<ol>
<li>
<p>Face-based polar representation, and mixed-integer directional algorithms.</p>
</li>
<li>
<p>Support for 3D <em>Octahedral</em> fields <sup id="fnref:solomon_2017"><a class="footnote-ref" href="#fn:solomon_2017" rel="footnote">14</a></sup>, both in tet meshes and with the boundary-element method.</p>
</li>
<li>
<p>A discrete exterior calculus framework.</p>
</li>
<li>
<p>Differential operators and Hodge decomposition.</p>
</li>
<li>
<p>Cutting, integration, and parameterization. Note the libigl has this capacity that could be called from Directional, but they are not entirely compatible.</p>
</li>
<li>
<p>Support for tensor fields.</p>
</li>
<li>
<p>Advanced and better visualization techniques.</p>
</li>
</ol>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<div class="footnote">
<hr />
<ol>
<li id="fn:azencot_2017">
<p>Omri Azencot, Etienne Corman, Mirela Ben-Chen, Maks Ovsjanikov, <a href="http://www.cs.technion.ac.il/~mirela/publications/cfc.pdf">Consistent Functional Cross Field Design for Mesh Quadrangulation</a>, 2017.&#160;<a class="footnote-backref" href="#fnref:azencot_2017" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:bommes_2009">
<p>David Bommes, Henrik Zimmer, Leif Kobbelt, <a href="http://www-sop.inria.fr/members/David.Bommes/publications/miq.pdf">Mixed-integer quadrangulation</a>, 2009.&#160;<a class="footnote-backref" href="#fnref:bommes_2009" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:bommes_2009" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:Bommes_2012">
<p>David Bommes, Henrik Zimmer, Leif Kobbelt, <a href="https://www.graphics.rwth-aachen.de/publication/0319/">Practical Mixed-Integer Optimization for Geometry Processing</a>, 2012.&#160;<a class="footnote-backref" href="#fnref:Bommes_2012" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:bouaziz_2012">
<p>Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly, <a href="http://lgg.epfl.ch/publications/2012/shapeup.pdf">Shape-Up: Shaping Discrete Geometry with Projections</a>, 2012.&#160;<a class="footnote-backref" href="#fnref:bouaziz_2012" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:crane_2010">
<p>Keenan Crane, Mathieu Desbrun, Peter Schr&ouml;der, <a href="https://www.cs.cmu.edu/~kmcrane/Projects/TrivialConnections/">Trivial Connections on Discrete Surfaces</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:crane_2010" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:crane_2010" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:crane_2010" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:crane_2010" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:diamanti_2014">
<p>Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, <a href="http://igl.ethz.ch/projects/complex-roots/">Designing N-PolyVector Fields with Complex Polynomials</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:diamanti_2014" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:diamanti_2014" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:diamanti_2014" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:diamanti_2014" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:diamanti_2015">
<p>Olga Diamanti, Amir Vaxman, Daniele Panozzo, Olga Sorkine-Hornung, <a href="http://igl.ethz.ch/projects/integrable/">Integrable PolyVector Fields</a>, 2015.&#160;<a class="footnote-backref" href="#fnref:diamanti_2015" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:degoes_2016">
<p>Fernando de Goes, Mathieu Desbrun, Yiying Tong, <a href="http://geometry.caltech.edu/pubs/dGDT16.pdf">Vector Field Processing on Triangle Meshes</a>, 2016.&#160;<a class="footnote-backref" href="#fnref:degoes_2016" rev="footnote" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:Kaelberer_2007">
<p>Felix K&auml;lberer, Matthias Nieser, Konrad Polthier, <a href="http://www.mi.fu-berlin.de/en/math/groups/ag-geom/publications/ressources/db/KNP07-QuadCover.pdf">QuadCover - Surface Parameterization using Branched Coverings</a>, 2007&#160;<a class="footnote-backref" href="#fnref:Kaelberer_2007" rev="footnote" title="Jump back to footnote 9 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:Kaelberer_2007" rev="footnote" title="Jump back to footnote 9 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:Kaelberer_2007" rev="footnote" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:knoppel_2013">
<p>Felix Kn&ouml;ppel, Keenan Crane, Ulrich Pinkall, and Peter Schr&ouml;der, <a href="http://www.cs.columbia.edu/~keenan/Projects/GloballyOptimalDirectionFields/paper.pdf">Globally Optimal Direction Fields</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:knoppel_2013" rev="footnote" title="Jump back to footnote 10 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:knoppel_2013" rev="footnote" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:ray_2008">
<p>Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno Lévy, <a href="http://alice.loria.fr/publications/papers/2008/DGF/NSDFD-TOG.pdf">N-Symmetry Direction Field Design</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:ray_2008" rev="footnote" title="Jump back to footnote 11 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:ray_2008" rev="footnote" title="Jump back to footnote 11 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:ray_2008" rev="footnote" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:liu_2011">
<p>Yang Liu, Weiwei Xu, Jun Wang, Lifeng Zhu, Baining Guo, Falai Chen, Guoping Wang, <a href="http://research.microsoft.com/en-us/um/people/yangliu/publication/cdf.pdf">General Planar Quadrilateral Mesh Design Using Conjugate Direction Field</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:liu_2011" rev="footnote" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:Myles_2014">
<p>Ashish Myles, Nico Pietroni, Denis Zorin, <a href="http://vcg.isti.cnr.it/Publications/2014/MPZ14/">Robust Field-aligned Global Parametrization</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:Myles_2014" rev="footnote" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:solomon_2017">
<p>Justin Solomon, Amir Vaxman, David Bommes, <a href="http://www.staff.science.uu.nl/~vaxma001/frames3d.pdf">Boundary Element Octahedral Fields in Volumes</a>, 2017.&#160;<a class="footnote-backref" href="#fnref:solomon_2017" rev="footnote" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:panozzo_2014">
<p>Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung,  <a href="http://cs.nyu.edu/~panozzo/papers/frame-fields-2014.pdf">Frame Fields: Anisotropic and Non-Orthogonal Cross Fields</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:panozzo_2014" rev="footnote" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
<li id="fn:vaxman_2016">
<p>Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen, <a href="https://github.com/avaxman/DirectionalFieldSynthesis">Directional Field Synthesis, Design, and Processing</a>, 2016.&#160;<a class="footnote-backref" href="#fnref:vaxman_2016" rev="footnote" title="Jump back to footnote 16 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:vaxman_2016" rev="footnote" title="Jump back to footnote 16 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href=".." title="Home" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Home
              </span>
            </div>
          </a>
        
        
          <a href="../file_formats/" title="File Formats" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                File Formats
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/avaxman" class="md-footer-social__link fa fa-github"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.583bbe55.js"></script>
      
      <script>app.initialize({version:"1.0.1",url:{base:".."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>